// multiSignalChart.js - Çoklu sinyal izleme grafiği için kod
// Chart.js import (date adapter kaldırıldı - linear zaman ekseni kullanılacak)
import { Chart, registerables } from 'chart.js';
// Chart.js tree-shaking nedeniyle gerekli bileşenleri kaydet
Chart.register(...registerables);

// Chart.js için gerekli renk paleti
const CHART_COLORS = {
  red: 'rgb(255, 99, 132)',
  orange: 'rgb(255, 159, 64)',
  yellow: 'rgb(255, 205, 86)',
  green: 'rgb(75, 192, 192)',
  blue: 'rgb(54, 162, 235)',
  purple: 'rgb(153, 102, 255)',
  grey: 'rgb(201, 203, 207)',
  teal: 'rgb(0, 128, 128)',
  lime: 'rgb(0, 255, 0)',
  pink: 'rgb(255, 0, 255)'
};

// Renk paletinden daha şeffaf versiyonlar oluşturma
const CHART_COLORS_TRANSPARENT = Object.fromEntries(
  Object.entries(CHART_COLORS).map(([key, value]) => [
    key,
    value.replace('rgb', 'rgba').replace(')', ', 0.2)')
  ])
);

// Maksimum veri noktası sayısı - 1 dakikalık veri (10 fps ile)
const MAX_DATA_POINTS = 600;

export class MultiSignalChart {
  constructor(canvasId, legendId) {
    this.canvasId = canvasId;
    this.legendId = legendId;
    this.selectedSignals = new Set();
    this.signalData = {};
    this.chart = null;
    this.maxSignals = 5;
    this.colorIndex = 0;
    this.colorNames = Object.keys(CHART_COLORS);
    this._lastUpdateTime = null;
    this._updateScheduled = false;
    this._visible = false;
    this._allAvailableSignals = new Map(); // Kullanılabilir tüm sinyalleri sakla
    this._searchInitialized = false;
    
    // Grafik oluşturma
    this.initChart();
    
    // Temizleme butonunu dinle (artık ana clearCharts düğmesini kullanacağız)
    document.getElementById('clearCharts')?.addEventListener('click', () => this.clearData());
  }

  // Chart.js grafiğini başlat
  initChart() {
    const canvas = document.getElementById(this.canvasId);
    console.log('initChart çağrıldı, canvas ID:', this.canvasId, 'canvas element:', canvas);
    if (!canvas) {
      console.error('Canvas elementi bulunamadı:', this.canvasId);
      return;
    }
    
    try {
      // Canvas boyutlarını doğru hesapla
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      
      // Canvas görünürlüğünü kontrol et
      const containerVisible = canvas.closest('.signal-panel')?.offsetParent !== null;
      
      if (rect.width === 0 || rect.height === 0 || !containerVisible) {
        console.warn('Canvas görünmez veya boyutları sıfır, boyutlandırma erteleniyor');
        canvas.style.width = '100%';
        canvas.style.height = '300px';
        // Görünür olmadığından veya boyutu hesaplanamadığından varsayılan değerler kullan
        canvas.width = 800 * dpr;
        canvas.height = 300 * dpr;
      } else {
        console.log('Canvas boyutları:', rect.width, 'x', rect.height);
        canvas.style.width = '100%';
        canvas.style.height = '300px';
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }
      
      // Mevcut grafiği temizle
      if (this.chart) {
        this.chart.destroy();
      }
    } catch (err) {
      console.error('Canvas boyutlandırma hatası:', err);
      // Hata durumunda varsayılan boyutlar
      canvas.style.width = '100%';
      canvas.style.height = '300px';
      canvas.width = 800;
      canvas.height = 300;
    }
    
    const chartConfig = {
      type: 'line',
      data: {
        datasets: []
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: {
          mode: 'nearest',
          axis: 'x',
          intersect: false
        },
        plugins: {
          tooltip: {
            enabled: true,
            position: 'nearest',
            backgroundColor: 'rgba(17, 24, 39, 0.9)',
            titleColor: '#e5e7eb',
            bodyColor: '#e5e7eb',
            borderColor: '#374151',
            borderWidth: 1,
            padding: 10,
            displayColors: true,
            callbacks: {
              label: (context) => {
                const dataset = context.dataset;
                const value = context.raw;
                return `${dataset.label}: ${value.toFixed(2)}`;
              },
              title: (tooltipItems) => {
                const date = new Date(tooltipItems[0].parsed.x);
                return date.toLocaleTimeString();
              }
            }
          },
          legend: {
            display: false
          }
        },
        scales: {
          x: {
            type: 'linear',
            grid: { color: 'rgba(255, 255, 255, 0.05)' },
            ticks: {
              color: '#9ca3af',
              maxRotation: 0,
              font: { size: 10 },
              callback: (v) => {
                const d = new Date(v);
                return d.toLocaleTimeString();
              }
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(255, 255, 255, 0.05)'
            },
            ticks: {
              color: '#9ca3af',
              font: {
                size: 10
              }
            }
          }
        }
      }
    };
    
    try {
      // createChartCore yerine doğrudan Chart.js kullan
      console.log('Chart.js ile grafik oluşturuluyor, config:', chartConfig);
      this.chart = new Chart(canvas, chartConfig);
      console.log('Chart başarıyla oluşturuldu:', this.chart);
      
      // Canvas boyutunu düzelt ve resize işlemini birkaç kez tekrarla
      // Bu, bazı tarayıcılarda görünürlük değişimlerinde boyutlandırma sorunlarını çözer
      setTimeout(() => {
        if (this.chart) {
          canvas.style.width = '100%';
          canvas.style.height = '300px';
          this.chart.resize();
          console.log('Chart boyutu ayarlandı:', canvas.width, 'x', canvas.height);
          
          // İkinci bir resize 200ms sonra
          setTimeout(() => {
            if (this.chart) {
              this.chart.resize();
              console.log('Chart boyutu tekrar ayarlandı');
            }
          }, 200);
        }
      }, 100);
    } catch (err) {
      console.error('Chart oluşturma hatası:', err);
    }
  }
  
  // Kullanılabilir sinyallerin listesini güncelleme
  updateAvailableSignals(signals) {
    const checkboxesContainer = document.getElementById('multiSignalCheckboxes');
    if (!checkboxesContainer) return;
    
    // Yeni gelen sinyalleri takip et
    if (!this._allAvailableSignals) {
      this._allAvailableSignals = new Map();
    }
    
    // Yeni gelen sinyalleri listeye ekle
    signals.forEach(signal => {
      if (!this._allAvailableSignals.has(signal.id)) {
        this._allAvailableSignals.set(signal.id, {
          id: signal.id,
          name: signal.name || signal.id,
          lastValue: null,
          lastUpdated: Date.now()
        });
        
        // Yeni sinyal için kontrol kutusu oluştur
        this._createSignalCheckbox(signal.id, signal.name || signal.id, checkboxesContainer);
      } else {
        // Varolan sinyali güncelle
        const existingSignal = this._allAvailableSignals.get(signal.id);
        existingSignal.lastUpdated = Date.now();
      }
    });
    
    // Sinyal sayısı güncellemesini göster
    this._updateSignalCounter();
    
    // Sinyal arama etkinleştir
    this._setupSignalSearch();
    
    // Sinyaller değiştiyse lejantı güncelle
    this.updateLegend();
  }
  
  // Sinyal checkbox'ı oluştur
  _createSignalCheckbox(signalId, signalName, container) {
    // Kontrol et, varsa oluşturma
    if (document.getElementById(`signal-${signalId.replace(/\s+/g, '-')}`)) {
      return;
    }
    
    const signalIdSafe = `signal-${signalId.replace(/\s+/g, '-')}`;
    const checkboxDiv = document.createElement('div');
    checkboxDiv.className = `signal-checkbox ${this.selectedSignals.has(signalId) ? 'checked' : ''}`;
    checkboxDiv.dataset.signalId = signalId;
    checkboxDiv.dataset.signalName = signalName.toLowerCase();
    
    // Renk göstergesi
    const colorIndex = this._allAvailableSignals.size % this.colorNames.length;
    const colorIndicator = document.createElement('span');
    colorIndicator.className = 'color-indicator';
    colorIndicator.style.backgroundColor = CHART_COLORS[this.colorNames[colorIndex]];
    checkboxDiv.appendChild(colorIndicator);
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = signalIdSafe;
    checkbox.checked = this.selectedSignals.has(signalId);
    
    const label = document.createElement('label');
    label.htmlFor = signalIdSafe;
    label.textContent = signalName;
    
    checkboxDiv.appendChild(checkbox);
    checkboxDiv.appendChild(label);
    
    // Kontrol kutusuna tıklama işleyicisi
    checkboxDiv.addEventListener('click', (e) => {
      // Eğer çoktan tıklanmışsa çift tıklamayı önle
      if (checkboxDiv.classList.contains('processing')) {
        return;
      }
      checkboxDiv.classList.add('processing');
      
      setTimeout(() => {
        if (this.selectedSignals.has(signalId)) {
          // Sinyali kaldır
          this.selectedSignals.delete(signalId);
          checkboxDiv.classList.remove('checked');
          checkbox.checked = false;
          this.removeSignalFromChart(signalId);
        } else {
          // Maksimum sinyal sayısı kontrolü
          if (this.selectedSignals.size >= this.maxSignals) {
            alert(`En fazla ${this.maxSignals} sinyal seçebilirsiniz.`);
            checkbox.checked = false;
            checkboxDiv.classList.remove('processing');
            return;
          }
          
          // Sinyali ekle
          this.selectedSignals.add(signalId);
          checkboxDiv.classList.add('checked');
          checkbox.checked = true;
          this.addSignalToChart(signalId, signalName);
        }
        
        this.updateLegend();
        checkboxDiv.classList.remove('processing');
      }, 10);
    });
    
    // Alfabetik sırada ekle
    let inserted = false;
    for (const child of container.children) {
      if (child.dataset.signalName > signalName.toLowerCase()) {
        container.insertBefore(checkboxDiv, child);
        inserted = true;
        break;
      }
    }
    
    if (!inserted) {
      container.appendChild(checkboxDiv);
    }
  }
  
  // Sinyal sayaç etiketini güncelle
  _updateSignalCounter() {
    const countElement = document.getElementById('signalCount');
    if (countElement && this._allAvailableSignals) {
      countElement.textContent = `(${this._allAvailableSignals.size})`;
    }
  }
  
  // Sinyal arama fonksiyonu
  _setupSignalSearch() {
    const searchInput = document.getElementById('signalSearchInput');
    if (!searchInput || this._searchInitialized) return;
    
    this._searchInitialized = true;
    
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const checkboxes = document.querySelectorAll('#multiSignalCheckboxes .signal-checkbox');
      
      checkboxes.forEach(checkbox => {
        const signalName = checkbox.dataset.signalName;
        if (!searchTerm || signalName.includes(searchTerm)) {
          checkbox.classList.remove('hidden');
        } else {
          checkbox.classList.add('hidden');
        }
      });
    });
  }
  
  // Grafiğe yeni sinyal ekleme
  addSignalToChart(signalId, signalName) {
    // Bu sinyal için veriler oluştur
    this.signalData[signalId] = [];
    
    // Bu sinyal için renk seçimi yap
    const colorName = this.colorNames[this.colorIndex % this.colorNames.length];
    this.colorIndex++;
    
    // Grafik veri kümesi oluştur
    const dataset = {
      label: signalName,
      data: this.signalData[signalId],
      borderColor: CHART_COLORS[colorName],
      backgroundColor: CHART_COLORS_TRANSPARENT[colorName],
      borderWidth: 1.5,
      pointRadius: 0,
      tension: 0.2,
      fill: false
    };
    
  if(!this.chart) return; // güvenlik
  this.chart.data.datasets.push(dataset);
  this.chart.update();
  }
  
  // Grafiği çizme/güncelleme metodu
  draw() {
    if (!this.chart) {
      // Grafik henüz oluşturulmamışsa, tekrar başlatmayı dene
      console.log('Grafik henüz oluşturulmamış, yeniden başlatılıyor...');
      this.initChart();
      return;
    }
    
    try {
      // Canvas boyutlarını tekrar ayarla ve grafiği güncelle
      const canvas = document.getElementById(this.canvasId);
      if (canvas) {
        canvas.style.width = '100%';
        canvas.style.height = '300px';
        this.chart.resize();
        this.chart.update();
        console.log('MultiSignalChart çizildi ve güncellendi.');
      }
    } catch (err) {
      console.error('MultiSignalChart çizim hatası:', err);
    }
  }
  
  // Grafikten sinyal kaldırma
  removeSignalFromChart(signalId) {
  if(!this.chart) return;
  const datasetIndex = this.chart.data.datasets.findIndex(dataset => dataset.label === signalId || dataset.signalId === signalId);
    
    if (datasetIndex !== -1) {
      this.chart.data.datasets.splice(datasetIndex, 1);
      this.chart.update();
    }
    
    // Veri yapısından da kaldır
    delete this.signalData[signalId];
  }
  
  // Sinyal verisini güncelleme
  updateSignalData(signalId, value) {
    // Sinyal listesinde varsa güncelle
    if (this._allAvailableSignals && this._allAvailableSignals.has(signalId)) {
      const signalInfo = this._allAvailableSignals.get(signalId);
      signalInfo.lastValue = value;
      signalInfo.lastUpdated = Date.now();
    }
    
    // Bu sinyal seçili değilse grafik için güncelleme yapma
    if (!this.selectedSignals.has(signalId) || !this.chart) return;
    
    // Zaman damgası oluştur (milisaniye cinsinden)
    const timestamp = Date.now();
    
    // Bu sinyal için veri dizisini al veya oluştur
    if (!this.signalData[signalId]) {
      this.signalData[signalId] = [];
    }
    
    // Sayısal değer kontrolü
    if (typeof value !== 'number' || isNaN(value)) {
      console.warn(`Geçersiz sinyal değeri: ${signalId} = ${value}`);
      return;
    }
    
    // Veri noktasını ekle
    this.signalData[signalId].push({
      x: timestamp,
      y: value
    });
    
    // Veri noktası sayısını sınırla (eskiden yeniye doğru)
    if (this.signalData[signalId].length > MAX_DATA_POINTS) {
      this.signalData[signalId] = this.signalData[signalId].slice(-MAX_DATA_POINTS);
    }
    
    // Performans optimizasyonu: Her veri ekleme için güncelleme yapmak yerine
    // sadece belirli aralıklarla güncelleme yap
    const updateInterval = 150; // 150ms'de bir güncelleme (daha yüksek performans için)
    
    if (!this._lastUpdateTime || (timestamp - this._lastUpdateTime) > updateInterval) {
      if (this.chart && this._visible) {
        // Asenkron olarak güncelleme yap, akıcılığı artır
        if (!this._updateScheduled) {
          this._updateScheduled = true;
          requestAnimationFrame(() => {
            if (this.chart) {
              this.chart.update('none'); // animasyon olmadan güncelleme
            }
            this._updateScheduled = false;
          });
        }
      }
      this._lastUpdateTime = timestamp;
    }
  }
  
  // Tüm veriyi temizleme
  clearData() {
    // Tüm sinyal verilerini temizle
    Object.keys(this.signalData).forEach(signalId => {
      this.signalData[signalId] = [];
    });
    
    // Grafik veri kümelerini güncelle
    if(this.chart){
      this.chart.data.datasets.forEach(dataset => { dataset.data = []; });
      this.chart.update();
    }
  }
  
  // Renk lejantını güncelleme
  updateLegend() {
    if(!this.chart) return;
    const legendContainer = document.getElementById(this.legendId);
    if (!legendContainer) return;
    legendContainer.innerHTML = '';
    for(const dataset of this.chart.data.datasets){
      const legendItem = document.createElement('div');
      legendItem.className = 'legend-item';
      const colorBox = document.createElement('div');
      colorBox.className = 'legend-color';
      colorBox.style.backgroundColor = dataset.borderColor;
      const label = document.createElement('span');
      label.textContent = dataset.label;
      legendItem.appendChild(colorBox);
      legendItem.appendChild(label);
      legendContainer.appendChild(legendItem);
    }
  }
  
  // Grafiğin görünürlüğünü ayarla
  setVisible(visible) {
    console.log(`MultiSignalChart görünürlüğü değiştiriliyor: ${visible ? 'görünür' : 'gizli'}`);
    
    this._visible = visible;
    
    // Canvas elementinin görünürlüğünü ayarla
    const canvas = document.getElementById(this.canvasId);
    if (!canvas) return;
    
    // Konteyner elementi al
    const containerEl = canvas.closest('.signal-panel') || canvas.closest('.signal-chart-container');
    
    if (visible) {
      // Görünür yapılırken, tekrar boyutlandırma yaparak grafiğin doğru şekilde çizilmesini sağla
      canvas.style.display = 'block';
      if (containerEl) containerEl.style.opacity = '1';
      
      // Önce bir kare geçmesini bekleyip sonra grafik düzenini güncelle
      requestAnimationFrame(() => {
        // Ardından, biraz daha gecikme ekleyerek CSS geçişlerinin tamamlanmasını bekle
        setTimeout(() => {
          if (!this.chart) {
            // Grafik oluşturulmamışsa yeniden oluştur
            this.initChart();
          } else {
            // Grafik varsa, yeniden boyutlandır
            const rect = canvas.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              canvas.width = rect.width * (window.devicePixelRatio || 1);
              canvas.height = rect.height * (window.devicePixelRatio || 1);
              this.chart.resize();
              this.chart.update('none'); // animasyonsuz güncelle
              console.log('Grafik görünür yapıldı ve boyutlandırıldı:', rect.width, 'x', rect.height);
            } else {
              console.warn('Canvas boyutları sıfır:', rect);
            }
          }
        }, 100);
      });
    } else {
      // Gizli yapılırken, performans için güncellemeyi durdur
      if (containerEl) containerEl.style.opacity = '0';
      setTimeout(() => {
        canvas.style.display = 'none';
      }, 300); // geçiş animasyonu için zaman tanı
    }
  }
}

// Modül dışa aktarımı
export default MultiSignalChart;
